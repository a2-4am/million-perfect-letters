;license:MIT
;(c) 2020 by 4am
;
; common graphics functions
;

GlobalLeftMargin
         !byte $0A

Home
; in:    none, but assumes text screen 1 is clear (this is done at program startup)
; out:   hi-res page 1 cleared and displayed
         bit   PAGE1
         bit   FULLGFX
         bit   HIRES
         bit   TEXTMODE
         ldy   #$00
         tya
-        sta   $2000, y
         sta   $2100, y
         sta   $2200, y
         sta   $2300, y
         sta   $2400, y
         sta   $2500, y
         sta   $2600, y
         sta   $2700, y
         sta   $2800, y
         sta   $2900, y
         sta   $2A00, y
         sta   $2B00, y
         sta   $2C00, y
         sta   $2D00, y
         sta   $2E00, y
         sta   $2F00, y
         sta   $3000, y
         sta   $3100, y
         sta   $3200, y
         sta   $3300, y
         sta   $3400, y
         sta   $3500, y
         sta   $3600, y
         sta   $3700, y
         sta   $3800, y
         sta   $3900, y
         sta   $3A00, y
         sta   $3B00, y
         sta   $3C00, y
         sta   $3D00, y
         sta   $3E00, y
         sta   $3F00, y
         iny
         bne   -
         bit   GFXMODE
         rts

WaitForKeyWithTimeout
; in:    A = timeout length (like standard $FCA8 wait routine)
; out:   A clobbered
;        X/Y preserved
         sec
@wait1   pha
@wait2   sbc   #1
         bne   @wait2
         pla
         bit   $C000
         bmi   @exit
         sbc   #1
         bne   @wait1
@exit    rts

ScrollDown
; in:    Y = logical column to scroll
; out:   X/Y preserved
         stx   @x+1
         sty   @y+1
         ldx   #$16
         jsr   LogicalColumnToPhysicalColumn
         jsr   InitScrollStorage
         jsr   WaitForVBL
         jsr   GENSCROLLDOWN
         jsr   UnwaitForVBL
@x       ldx   #$FD                  ; SMC
@y       ldy   #$FD                  ; SMC
         rts

ScrollUp
; in:    Y = logical column to scroll
; out:   X/Y preserved
         stx   @x+1
         sty   @y+1
         ldx   #$16
         jsr   LogicalColumnToPhysicalColumn
         jsr   InitScrollStorage
         jsr   WaitForVBL
         jsr   GENSCROLLUP
         jsr   UnwaitForVBL
@x       ldx   #$FD                  ; SMC
@y       ldy   #$FD                  ; SMC
         rts

InitScrollStorage
         lda   #$00
         sta   $FC
         sta   $FD
         sta   $FE
         sta   $FF
         rts

LogicalColumnToPhysicalColumn
; in:    Y contains logical column number
; out:   Y contains physical byte offset to use against an HGR base address
;        A clobbered
;        X preserved
         lda   GlobalLeftMargin
         clc
         bcc   +
-        adc   #$03
+        dey
         bpl   -
         tay
         rts

nonZeroDigits = $EE
paddingCharacter = $EF
ToASCIIString
; convert byte value to length-prefixed 3-digit decimal number as ASCII string with given padding character
; in:    X = any number (0..255 obviously)
;        A = padding character (e.g. '0' or ' ')
; out:   $F1 = 0x03
;        $F2..$F4 = ASCII digits of decimal representation
;        clobbers $EE,$EF,$F0
;        all flags & registers clobbered
         sta   paddingCharacter
         stx   $F0
         ldx   #0
         stx   nonZeroDigits
         stx   $F1
@outer   lda   #0
         pha
@inner   lda   $F0
         cmp   @kPowersOfTen, x
         bcc   @digitDone
         sbc   @kPowersOfTen, x
         sta   $F0
         lda   $F1
         sbc   #0
         sta   $F1
         pla
         adc   #0
         pha
         jmp   @inner
@digitDone
         pla
         beq   @maybeUsePaddingChar
         inc   nonZeroDigits
-        ora   #$30
         bne   +                     ; always branches
@maybeUsePaddingChar
         cpx   #2
         beq   -
         ldy   nonZeroDigits
         bne   -
         lda   paddingCharacter
+        sta   $F2, x
         inx
         cpx   #$03
         bcc   @outer
         lda   #3                    ; length byte
         sta   $F1
         rts
@kPowersOfTen
         !byte 100
         !byte 10
         !byte 1
